<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "https://www.docbook.org/xml/4.4/docbookx.dtd">
<chapter id="tutorial_relationships">
    <title>Relationships</title>
    <subtitle>A convincing act</subtitle>
    <para>
        Our application was not yet very much fun yet, just storing movies and actors. After all,
        the power is in the relationships between them. Fortunately, Neo4j treats relationships as first class citizens,
        allowing them to be addressed individually and assigned properties. That allows for representing them as entities
        if needed.
    </para>
    <section>
        <title>Creating relationships</title>
        <para>
            Relationships without properties ("anonymous" relationships) don't require any @RelationshipEntity
            classes. Unfortunately we had none of those, because our relationships were richer.
            Therefore we went with the Role relationship between Movie and Actor.
            It had to be annotated with @RelationshipEntity and the @StartNode and @EndNode had to be marked.
            So our Role looked like this:
        </para>
        <para>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="relationship.png" align="center"/>
                </imageobject>
            </mediaobject>
        </para>
        <para>
            <example>
                <title>Role class</title>
                <programlisting language="java"><![CDATA[@RelationshipEntity
class Role {
    @StartNode Actor actor;
    @EndNode Movie movie;
    String role;
}
]]></programlisting>
            </example>
        </para>
        <para>
            When writing a test for that we tried to create the relationship entity with the <code>new</code>
            keyword, but we got an exception saying that it was not allowed. At first this surprised us, but
            then we realized that a relationship entity must have a starting entity and ending entity. It
            turned out that the aspect had introduced a <code>entity.relateTo</code> method in the node entities.
            It turned out to be exactly what we needed. We simply added a method to the Actor class, connecting
            it to movies.
        </para>
        <para>
            <example>
                <title>Relating actors to movies</title>
                <programlisting language="java" ><![CDATA[class Actor {
...
    public Role playedIn(Movie movie, String roleName) {
        Role role = relateTo(movie, Role.class, "ACTS_IN");
        role.setRole(roleName);
        return role;
    }
}
]]></programlisting>
            </example>
        </para>
    </section>
    <section>
        <title>Accessing related entities</title>
        <para>
            Now we wanted to find connected entities.
            We already had fields for the relationships in both classes. It was time to annotate them
            correctly. It turned out that we needed to provide the target type of the fields again, due to
            Java's type erasure. The Neo4j relationship type and direction were easy to figure out.
            The direction even defaulted to outgoing, so we only had to specify it for the movie.
        </para>
        <para>
            <example>
                <title>@RelatedTo usage</title>
                <programlisting language="java" ><![CDATA[@NodeEntity
class Movie {
    @Indexed int id;
    String title;
    int year;
    @RelatedTo(elementClass = Actor.class, type = "ACTS_IN", direction = Direction.INCOMING)
    Set<Actor> cast;
}

@NodeEntity
class Actor {
    @Indexed int id;
    String name;
    @RelatedTo(elementClass = Movie.class, type = "ACTS_IN")
    Set<Movie> movies;

    public Role playedIn(Movie movie, String roleName) {
        Role role = relateTo(movie, Role.class, "ACTS_IN");
        role.setRole(roleName);
        return role;
    }
}
]]></programlisting>
            </example>
        </para>
        <para>
            While reading about these relationship collections, we learned that they are actually
            Spring Data Graph-managed sets. So whenever we add or remove something from the set,
            it automatically gets reflected in the underlying relationships. That's neat! But this
            also meant we did not need to initialize the fields. That could be easy to forget.
        </para>
        <para>
            We made sure to add a test for those, so we were assured that the collections worked as
            advertised.
        </para>
    </section>
    <section>
        <title>Accessing the relationship entities</title>
        <para>
            But we still couldn't access the Role relationships. It turned out that there was a separate
            annotation <code>@RelatedToVia</code> for accessing the actual relationship entities. And we had
            to declare the field as an Iterable&lt;Role&gt;, with read-only semantics. This appeared to mean
            that we were not able to add new roles through the field. Adding relationship entities seemed like
            it had to be done by using <code>entity.relateTo()</code>. The annotation attributes were similar to
            those used for <code>@RelatedTo</code>. So off we went, creating our first real relationship (just kidding).
        </para>
        <para>
            <example>
                <title>@RelatedToVia usage</title>
                <programlisting language="java" ><![CDATA[@NodeEntity
class Movie {
    @Indexed int id;
    String title;
    int year;
    @RelatedTo(elementClass = Actor.class, type = "ACTS_IN", direction = Direction.INCOMING)
    Set<Actor> cast;

    @RelatedToVia(elementClass = Role.class, type = "ACTS_IN", direction = Direction.INCOMING)
    Iterable<Roles> roles;
}
]]></programlisting>
            </example>
        </para>
        <para>
            After watching the tests pass, we were confident that the relationship fields really mirrored
            the underlying relationships in the graph. We were pretty satisfied with our domain.
        </para>
    </section>
</chapter>
